\documentclass{article}
\usepackage{amssymb, amsmath, amsfonts, amsthm, graphicx, stmaryrd, listings, xcolor}

\definecolor{darkblue}{rgb}{0,0,0.5}
\definecolor{lightgray}{gray}{0.75}

\lstset{basicstyle=\ttfamily\small, numbers=left,
  xleftmargin=3em,extendedchars=true,
  numberstyle=\tiny\color{lightgray}, keywordstyle=\color{darkblue}, morekeywords={and,
    as, begin, check, do, done, downto, else, end, effect, external, finally,
    for, fun, function, handle, handler, if, in, match, let, new, of, operation,
    perform, rec, val, while, to, type, then, with},
literate=%
    {→}{{$\rightarrow$}}1%
    {×}{{$\times$}}1%
    {←}{{$\leftarrow$}}1%
    {↦}{{$\mapsto$}}1%
    {↝}{{$\leadsto$}}1%
    {…}{{$\ldots$}}1%
    {⇒}{{$\Rightarrow$}}1%
    {∈}{{$\in$}}1%
    {≡}{{$\equiv$}}1%
    {λ}{{$\lambda$}}1%
    {⊢}{{$\vdash$}}1%
    {κ}{{$\kappa$}}1%
    {Σ}{{$\Sigma$}}1%
    {Δ}{{$\Delta$}}1%
    {Γ}{{$\Gamma$}}1%
    {Θ}{{$\Theta$}}1%
    {₀}{{${}_0$}}1%
    {₁}{{${}_1$}}1%
    {₂}{{${}_2$}}1%
    {ᵢ}{{${}_\mathtt{i}$}}1%
    {ⱼ}{{${}_\mathtt{j}$}}1%
}

{\theoremstyle{definition}
\newtheorem{problem}{Problem}[section]}
\newcommand{\task}{\par\noindent\emph{Task:}\ }

\title{Algebraic Effects and Handlers}
\author{}
\date{}

\begin{document}

    \maketitle

    \section{The algebra stuff}
    \begin{problem}[The theory of an associative unital operation]
        Consider the theory $T$ of an associative operation with a unit.
        It has a constant $\epsilon$ and a binary operation $\cdot$
        satisfying equations
        %
        \begin{align*}
            (x \cdot y) \cdot z &= x \cdot (y \cdot z) \\
            \epsilon \cdot x &= x \\
            x \cdot \epsilon &= x
        \end{align*}
        %
        Give a useful description of the free model of $T$ generated by a
        set $X$. You can either guess an explicit construction of free
        models and show that it has the required universal property, or you can
        analyze the free model construction (equivalence classes of well-founded
        trees) and provide a simple description of it.
    \end{problem}
    \begin{proof}[Solution]
        I propose that, as with the semilattice example, the free model of $T$
        generated by a set $X$ has the carrier set $\mathcal{P}_{<\omega}(X)$ of
        all finite subsets of $X$, with $\llbracket\epsilon\rrbracket=\emptyset$
        and $\llbracket\cdot\rrbracket=\cup$. We have the same map $\eta : X\rightarrow
        \mathcal{P}_{<\omega}(X)$ defined by $x\mapsto \{x\}$.

        Given any other model $(T,\epsilon,\cdot)$ and a map $f : X\rightarrow
        |T|$, we can define the homomorphism $\overline{f}:
        \mathcal{P}_{<\omega}\rightarrow |L|$ by
        \[
            \overline{f}(\{x_1,x_2,\dots,x_n\})=f(x_1)\cdot f(x_2)\cdot \dots
            \cdot f(x_n).
        \]
        The diagram commutes because
        $\overline{f}(\eta(x))=\overline{f}(\{x\})=f(x)$. If $g$ is another
        homomorphism for which the diagram commutes, we must have
        \begin{align*}
            g(\{x_1,\dots,x_n\})=g(\eta(x_1)\cup\cdots\cup\eta(x_n))=g(\eta(x_1))\cdot\dots\cdot
            g(\eta(x_n)) \\
            = f(x_1)\cdot\cdots\cdot f(x_n)=\overline{f}(\{x_1,\dots,x_n\}),
        \end{align*}
        so $\overline{f}$ is unique.
    \end{proof}

    \begin{problem}[The theory of apocalypse]
    We formulate an algebraic theory $\mathsf{Time}$ in it is possible to
    explicitly record passage of time. The theory has a single unary
    operation $\mathsf{tick}$ and no equations. Each application of
    $\mathsf{tick}$ records the passage of one time step.

    \task Give a useful description of the free model of the
    theory, generated by a set $X$.

    \task Let a given fixed natural number $n$ be given.
    Describe a theory $\mathsf{Apocalypse}$ which extends the theory
    $\mathsf{Time}$ so that a computation crashes (aborts, necessarily
    terminates) if it performs more than $n$ of ticks. Give a useful
    description of its free models.

    Advice: do \emph{not} concern yourself with any sort of operational
    semantics which somehow ``aborts'' after $n$ ticks. Instead, use
    equations and postulate that certain computations are equal to an
    aborted one.
    \end{problem}
    \begin{proof}[Solution]
        We observe that the set
        $\textsf{Tree}_\textsf{Time}(X)$ is the set of sticks with
        $\textsf{return }x$ at their leaves and $\textsf{tick}$ at each node.
        Because we have no equations, the
        free model generated by $X$ is just the set of trees
        $\textsf{Tree}_\textsf{Time}(X)$, our map
        $\eta_X:X\rightarrow\textsf{Tree}_\textsf{Time}(X)$ maps $x$ to
        $\textsf{return }x$, and the interpretation of $\textsf{tick}$ just adds
        one more \textsf{tick} to a tree. A nice way to represent the carrier
        set of the free model generated by $X$ is as the set $X\times
        \mathbb{N}$ where the natural number (including 0) represents the number
        of ticks applied to a starting element in $X$. With this representation,
        the operation \textsf{tick} maps $(x,n)$ to $(x,n+1)$.

        The theory \textsf{Apocalypse} contains the equation
        $\textsf{tick}^n(x)=\textsf{tick}^{n+1}(x)$. In our tree repsesentation, we
        now have that all trees of height $n$ or greater are equal under
        $\approx_\textsf{Apocalypse}$. Note that we still differentiate between
        aborted computations that started in different places, which is just to
        make things simpler. This leads to the free model with carrier
        set $X\times\{0,\dots,n\}$ and the operation
        \[
            \textsf{tick}((x,m)) = \begin{cases}
                (x,m+1) & \text{if }m<n \\
                (x,m) & \text{if }m=n.
            \end{cases}
        \]
    \end{proof}

    \section{The language stuff}
    \begin{problem}[Products]
        Add simple products \lstinline{A × B} to the core language:
        %
        \begin{enumerate}
            \item Extend the syntax of values with pairs.
            \item Extend the syntax of computations with an elimination of pairs, e.g., \lstinline{do (x,y) ← c₁ in c₂}.
            \item Extend the operational semantics.
            \item Extend the typing rules.
        \end{enumerate}
    \end{problem}
    \begin{proof}[Solution]
        We extend the syntax of values as
        \begin{lstlisting}
v ::= ...
    | (v₁, v₂)      (pair)
        \end{lstlisting}
        and the syntax of computations as
        \begin{lstlisting}
c ::= ...
    | do (x,y) ← c₁ in c₂   (pair elim)
        \end{lstlisting}
        Our operational semantics are extended with the following rule:
        \begin{lstlisting}

____________________________________________________
do (x, y) ← return (v₁, v₂) in c₂  ↦  c₂[v₁/x, v₂/y]
        \end{lstlisting}
        The new definition for value type is:
        \begin{lstlisting}
        A, B := bool | A → C | C ⇒ D | A × B
        \end{lstlisting}
        We add one new rule for value typing:
        \begin{lstlisting}[mathescape=true]
$\Gamma\vdash$ x : A     $\Gamma\vdash$ y : B
--------------------
 $\Gamma\vdash$ (x, y) : A $\times$ B
        \end{lstlisting}
        and one new rule for computation typing:
        \begin{lstlisting}[mathescape=true]
Γ ⊢ c₁ : ($A_1$ $\times$ $A_2$)!Δ    Γ, x:$A_1$, y:$A_2$ ⊢ c₂ : B!Δ
_____________________________________________
      Γ ⊢ (do (x, y) ← c₁ in c₂) : B!Δ
        \end{lstlisting}
    \end{proof}

    \begin{problem}[Non-terminating program]
        Define a program which prints infinitely many booleans. You may assume that the
        \lstinline{print : bool → unit} operation is handled appropriately by the runtime
        environment. For extra credit, make it "funny".
    \end{problem}
    \begin{proof}[Solution]
        I think this works?
        \begin{lstlisting}[mathescape=true]
fix loop .
    with handler {
        return x $\mapsto$ return x,
        print(x, _) $\mapsto$ print(x, $\lambda$_ . loop)
    } handle print(true,
        $\lambda$_ . solve_world_hunger((), $\lambda$_ . return true))
        \end{lstlisting}
    \end{proof}
\end{document}
